# coding: utf-8

"""
    AVNU API

    REST API documentation for accessing liquidity on Layer 2.  AVNU is a decentralized exchange protocol enabling the fastest and the most efficient operations in DeFi for Layer 2 with better pricing, zero slippage, MEV-protection and gasless trading.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from avnu_python_client.models.build_swap_request import BuildSwapRequest
from avnu_python_client.models.build_swap_request_dto_v2 import BuildSwapRequestDtoV2
from avnu_python_client.models.build_swap_response import BuildSwapResponse
from avnu_python_client.models.build_swap_typed_data_request import BuildSwapTypedDataRequest
from avnu_python_client.models.execute_swap_request import ExecuteSwapRequest
from avnu_python_client.models.execute_swap_response import ExecuteSwapResponse
from avnu_python_client.models.quote import Quote
from avnu_python_client.models.typed_data import TypedData

from avnu_python_client.api_client import ApiClient, RequestSerialized
from avnu_python_client.api_response import ApiResponse
from avnu_python_client.rest import RESTResponseType


class SwapApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def build(
        self,
        build_swap_request_dto_v2: BuildSwapRequestDtoV2,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BuildSwapResponse:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request_dto_v2: (required)
        :type build_swap_request_dto_v2: BuildSwapRequestDtoV2
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_serialize(
            build_swap_request_dto_v2=build_swap_request_dto_v2,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def build_with_http_info(
        self,
        build_swap_request_dto_v2: BuildSwapRequestDtoV2,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BuildSwapResponse]:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request_dto_v2: (required)
        :type build_swap_request_dto_v2: BuildSwapRequestDtoV2
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_serialize(
            build_swap_request_dto_v2=build_swap_request_dto_v2,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def build_without_preload_content(
        self,
        build_swap_request_dto_v2: BuildSwapRequestDtoV2,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request_dto_v2: (required)
        :type build_swap_request_dto_v2: BuildSwapRequestDtoV2
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_serialize(
            build_swap_request_dto_v2=build_swap_request_dto_v2,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _build_serialize(
        self,
        build_swap_request_dto_v2,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter
        if build_swap_request_dto_v2 is not None:
            _body_params = build_swap_request_dto_v2


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swap/v2/build',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def build1(
        self,
        build_swap_request: BuildSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BuildSwapResponse:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request: (required)
        :type build_swap_request: BuildSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build1_serialize(
            build_swap_request=build_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def build1_with_http_info(
        self,
        build_swap_request: BuildSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BuildSwapResponse]:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request: (required)
        :type build_swap_request: BuildSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build1_serialize(
            build_swap_request=build_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def build1_without_preload_content(
        self,
        build_swap_request: BuildSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Build swap calldata

        The build endpoint enables traders to construct swap calldata, which can be used to execute the transaction independently. Prior to targeting the build endpoint, traders should have already chosen a quote from the GET /quotes endpoint.

        :param build_swap_request: (required)
        :type build_swap_request: BuildSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build1_serialize(
            build_swap_request=build_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "BuildSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _build1_serialize(
        self,
        build_swap_request,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter
        if build_swap_request is not None:
            _body_params = build_swap_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swap/v1/build',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def build_typed_data2(
        self,
        build_swap_typed_data_request: BuildSwapTypedDataRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TypedData:
        """build_typed_data2


        :param build_swap_typed_data_request: (required)
        :type build_swap_typed_data_request: BuildSwapTypedDataRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_typed_data2_serialize(
            build_swap_typed_data_request=build_swap_typed_data_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "TypedData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def build_typed_data2_with_http_info(
        self,
        build_swap_typed_data_request: BuildSwapTypedDataRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TypedData]:
        """build_typed_data2


        :param build_swap_typed_data_request: (required)
        :type build_swap_typed_data_request: BuildSwapTypedDataRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_typed_data2_serialize(
            build_swap_typed_data_request=build_swap_typed_data_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "TypedData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def build_typed_data2_without_preload_content(
        self,
        build_swap_typed_data_request: BuildSwapTypedDataRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """build_typed_data2


        :param build_swap_typed_data_request: (required)
        :type build_swap_typed_data_request: BuildSwapTypedDataRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_typed_data2_serialize(
            build_swap_typed_data_request=build_swap_typed_data_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "TypedData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _build_typed_data2_serialize(
        self,
        build_swap_typed_data_request,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter
        if build_swap_typed_data_request is not None:
            _body_params = build_swap_typed_data_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swap/v2/build-typed-data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def execute2(
        self,
        execute_swap_request: ExecuteSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecuteSwapResponse:
        """Execute swap

        This endpoint allows trader to execute swap transaction

        :param execute_swap_request: (required)
        :type execute_swap_request: ExecuteSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute2_serialize(
            execute_swap_request=execute_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def execute2_with_http_info(
        self,
        execute_swap_request: ExecuteSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecuteSwapResponse]:
        """Execute swap

        This endpoint allows trader to execute swap transaction

        :param execute_swap_request: (required)
        :type execute_swap_request: ExecuteSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute2_serialize(
            execute_swap_request=execute_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def execute2_without_preload_content(
        self,
        execute_swap_request: ExecuteSwapRequest,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Execute swap

        This endpoint allows trader to execute swap transaction

        :param execute_swap_request: (required)
        :type execute_swap_request: ExecuteSwapRequest
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._execute2_serialize(
            execute_swap_request=execute_swap_request,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _execute2_serialize(
        self,
        execute_swap_request,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter
        if execute_swap_request is not None:
            _body_params = execute_swap_request


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/swap/v2/execute',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_prices(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Quote:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_prices_with_http_info(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Quote]:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_prices_without_preload_content(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_prices_serialize(
        self,
        sell_token_address,
        buy_token_address,
        sell_amount,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sell_token_address is not None:
            
            _query_params.append(('sellTokenAddress', sell_token_address))
            
        if buy_token_address is not None:
            
            _query_params.append(('buyTokenAddress', buy_token_address))
            
        if sell_amount is not None:
            
            _query_params.append(('sellAmount', sell_amount))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v2/prices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_prices1(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Quote:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_prices1_with_http_info(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Quote]:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_prices1_without_preload_content(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[StrictStr, Field(description="The Amount of token user wants to sell")],
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find the prices of DEX applications

        This endpoint returns the prices of AMM without any path optimization. It allows to measure the performance of the results from the getQuotes endpoints. The prices will be returned and are sorted (best first).

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The Amount of token user wants to sell (required)
        :type sell_amount: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_prices1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_prices1_serialize(
        self,
        sell_token_address,
        buy_token_address,
        sell_amount,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sell_token_address is not None:
            
            _query_params.append(('sellTokenAddress', sell_token_address))
            
        if buy_token_address is not None:
            
            _query_params.append(('buyTokenAddress', buy_token_address))
            
        if sell_amount is not None:
            
            _query_params.append(('sellAmount', sell_amount))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v1/prices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_quotes(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Quote:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v2/build or /swap/v2/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_quotes_with_http_info(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Quote]:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v2/build or /swap/v2/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_quotes_without_preload_content(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v2/build or /swap/v2/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_quotes_serialize(
        self,
        sell_token_address,
        buy_token_address,
        sell_amount,
        buy_amount,
        taker_address,
        exclude_sources,
        size,
        integrator_fees,
        integrator_fee_recipient,
        integrator_name,
        only_direct,
        pulsar_money_fee_recipient_value,
        origin,
        user_agent,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'excludeSources': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sell_token_address is not None:
            
            _query_params.append(('sellTokenAddress', sell_token_address))
            
        if buy_token_address is not None:
            
            _query_params.append(('buyTokenAddress', buy_token_address))
            
        if sell_amount is not None:
            
            _query_params.append(('sellAmount', sell_amount))
            
        if buy_amount is not None:
            
            _query_params.append(('buyAmount', buy_amount))
            
        if taker_address is not None:
            
            _query_params.append(('takerAddress', taker_address))
            
        if exclude_sources is not None:
            
            _query_params.append(('excludeSources', exclude_sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if integrator_fees is not None:
            
            _query_params.append(('integratorFees', integrator_fees))
            
        if integrator_fee_recipient is not None:
            
            _query_params.append(('integratorFeeRecipient', integrator_fee_recipient))
            
        if integrator_name is not None:
            
            _query_params.append(('integratorName', integrator_name))
            
        if only_direct is not None:
            
            _query_params.append(('onlyDirect', only_direct))
            
        if pulsar_money_fee_recipient_value is not None:
            
            _query_params.append(('PULSAR_MONEY_FEE_RECIPIENT.value', pulsar_money_fee_recipient_value))
            
        # process the header parameters
        if origin is not None:
            _header_params['Origin'] = origin
        if user_agent is not None:
            _header_params['User-Agent'] = user_agent
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v2/quotes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_quotes1(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Quote:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v1/build or /swap/v1/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_quotes1_with_http_info(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Quote]:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v1/build or /swap/v1/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_quotes1_without_preload_content(
        self,
        sell_token_address: Annotated[StrictStr, Field(description="The token address user wants to sell")],
        buy_token_address: Annotated[StrictStr, Field(description="The token address user wants to buy")],
        sell_amount: Annotated[Optional[StrictStr], Field(description="The amount of token user wants to sell. It must be defined if buyAmount is not defined.")] = None,
        buy_amount: Annotated[Optional[StrictStr], Field(description="The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.")] = None,
        taker_address: Annotated[Optional[StrictStr], Field(description="The address which will fill the quote")] = None,
        exclude_sources: Annotated[Optional[List[StrictStr]], Field(description="The sources that the user wants to exclude")] = None,
        size: Annotated[Optional[Annotated[int, Field(le=5, strict=True, ge=1)]], Field(description="The maximum number of returned quotes")] = None,
        integrator_fees: Annotated[Optional[StrictStr], Field(description="Fee amount in bps, 30 is 0.3%")] = None,
        integrator_fee_recipient: Annotated[Optional[StrictStr], Field(description="Required when `integratorFees` is defined. You need to provide the address of your fee collector.")] = None,
        integrator_name: Annotated[Optional[StrictStr], Field(description="The name of your application")] = None,
        only_direct: Optional[StrictBool] = None,
        pulsar_money_fee_recipient_value: Optional[StrictInt] = None,
        origin: Optional[StrictStr] = None,
        user_agent: Optional[StrictStr] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Find the best quotes

        This endpoint permits you to receive the best quotes for performing a swap. The endpoint provides default quotes that are sorted in descending order (best first). Each quote is assigned a unique quoteId, which you will use when making calls to the /swap/v1/build or /swap/v1/execute endpoints to initiate the actual swap process.

        :param sell_token_address: The token address user wants to sell (required)
        :type sell_token_address: str
        :param buy_token_address: The token address user wants to buy (required)
        :type buy_token_address: str
        :param sell_amount: The amount of token user wants to sell. It must be defined if buyAmount is not defined.
        :type sell_amount: str
        :param buy_amount: The exact amount of token user wants to buy. It must be defined if sellAmount is not defined.
        :type buy_amount: str
        :param taker_address: The address which will fill the quote
        :type taker_address: str
        :param exclude_sources: The sources that the user wants to exclude
        :type exclude_sources: List[str]
        :param size: The maximum number of returned quotes
        :type size: int
        :param integrator_fees: Fee amount in bps, 30 is 0.3%
        :type integrator_fees: str
        :param integrator_fee_recipient: Required when `integratorFees` is defined. You need to provide the address of your fee collector.
        :type integrator_fee_recipient: str
        :param integrator_name: The name of your application
        :type integrator_name: str
        :param only_direct:
        :type only_direct: bool
        :param pulsar_money_fee_recipient_value:
        :type pulsar_money_fee_recipient_value: int
        :param origin:
        :type origin: str
        :param user_agent:
        :type user_agent: str
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_quotes1_serialize(
            sell_token_address=sell_token_address,
            buy_token_address=buy_token_address,
            sell_amount=sell_amount,
            buy_amount=buy_amount,
            taker_address=taker_address,
            exclude_sources=exclude_sources,
            size=size,
            integrator_fees=integrator_fees,
            integrator_fee_recipient=integrator_fee_recipient,
            integrator_name=integrator_name,
            only_direct=only_direct,
            pulsar_money_fee_recipient_value=pulsar_money_fee_recipient_value,
            origin=origin,
            user_agent=user_agent,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "Quote",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_quotes1_serialize(
        self,
        sell_token_address,
        buy_token_address,
        sell_amount,
        buy_amount,
        taker_address,
        exclude_sources,
        size,
        integrator_fees,
        integrator_fee_recipient,
        integrator_name,
        only_direct,
        pulsar_money_fee_recipient_value,
        origin,
        user_agent,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'excludeSources': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sell_token_address is not None:
            
            _query_params.append(('sellTokenAddress', sell_token_address))
            
        if buy_token_address is not None:
            
            _query_params.append(('buyTokenAddress', buy_token_address))
            
        if sell_amount is not None:
            
            _query_params.append(('sellAmount', sell_amount))
            
        if buy_amount is not None:
            
            _query_params.append(('buyAmount', buy_amount))
            
        if taker_address is not None:
            
            _query_params.append(('takerAddress', taker_address))
            
        if exclude_sources is not None:
            
            _query_params.append(('excludeSources', exclude_sources))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if integrator_fees is not None:
            
            _query_params.append(('integratorFees', integrator_fees))
            
        if integrator_fee_recipient is not None:
            
            _query_params.append(('integratorFeeRecipient', integrator_fee_recipient))
            
        if integrator_name is not None:
            
            _query_params.append(('integratorName', integrator_name))
            
        if only_direct is not None:
            
            _query_params.append(('onlyDirect', only_direct))
            
        if pulsar_money_fee_recipient_value is not None:
            
            _query_params.append(('PULSAR_MONEY_FEE_RECIPIENT.value', pulsar_money_fee_recipient_value))
            
        # process the header parameters
        if origin is not None:
            _header_params['Origin'] = origin
        if user_agent is not None:
            _header_params['User-Agent'] = user_agent
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json', 
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v1/quotes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sources(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecuteSwapResponse:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sources_with_http_info(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecuteSwapResponse]:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sources_without_preload_content(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sources_serialize(
        self,
        page,
        size,
        sort,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v2/sources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_sources1(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecuteSwapResponse:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_sources1_with_http_info(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecuteSwapResponse]:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_sources1_without_preload_content(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetch the list of supported sources

        This endpoint allows to return the list of all supported sources

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_sources1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_sources1_serialize(
        self,
        page,
        size,
        sort,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v1/sources',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tokens1(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecuteSwapResponse:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tokens1_with_http_info(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecuteSwapResponse]:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tokens1_without_preload_content(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens1_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tokens1_serialize(
        self,
        page,
        size,
        sort,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v2/tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tokens2(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExecuteSwapResponse:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens2_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tokens2_with_http_info(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExecuteSwapResponse]:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens2_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tokens2_without_preload_content(
        self,
        page: Annotated[Optional[StrictInt], Field(description="Zero-based page index (0..N)")] = None,
        size: Annotated[Optional[StrictInt], Field(description="The size of the page to be returned")] = None,
        sort: Annotated[Optional[List[StrictStr]], Field(description="Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.")] = None,
        ask_signature: Annotated[Optional[StrictStr], Field(description="When the given value is provided with the value 'true', the response header 'signature' will be returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fetch supported tokens

        This endpoint allows to fetch the list of all officially supported tokens

        :param page: Zero-based page index (0..N)
        :type page: int
        :param size: The size of the page to be returned
        :type size: int
        :param sort: Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
        :type sort: List[str]
        :param ask_signature: When the given value is provided with the value 'true', the response header 'signature' will be returned.
        :type ask_signature: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tokens2_serialize(
            page=page,
            size=size,
            sort=sort,
            ask_signature=ask_signature,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '400': "ErrorResponse",
            '500': "ErrorResponse",
            '429': "str",
            '401': "ErrorResponse",
            '200': "ExecuteSwapResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tokens2_serialize(
        self,
        page,
        size,
        sort,
        ask_signature,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'sort': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if page is not None:
            
            _query_params.append(('page', page))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        if ask_signature is not None:
            _header_params['ask-signature'] = ask_signature
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*', 
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/swap/v1/tokens',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


